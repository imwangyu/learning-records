<!-- TOC -->

- [1. MySQL架构与历史](#1-mysql%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%8E%86%E5%8F%B2)
    - [1.1. MySQL逻辑架构](#11-mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84)
        - [1.1.1. 连接管理与安全性](#111-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7)
        - [1.1.2. 优化与执行](#112-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%89%A7%E8%A1%8C)
    - [1.2. 并发控制](#12-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6)
        - [1.2.1. 读写锁](#121-%E8%AF%BB%E5%86%99%E9%94%81)
        - [1.2.2. 锁粒度](#122-%E9%94%81%E7%B2%92%E5%BA%A6)
    - [1.3. 事务](#13-%E4%BA%8B%E5%8A%A1)
        - [1.3.1. 隔离级别](#131-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB)
        - [1.3.2. 死锁](#132-%E6%AD%BB%E9%94%81)
        - [1.3.3. 事务日志](#133-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97)
        - [1.3.4. MySQL中的事务](#134-mysql%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1)
    - [1.4. 多版本并发控制](#14-%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6)
    - [1.5. MySQl的存储引擎](#15-mysql%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)
        - [1.5.1. InnoDB存储引擎](#151-innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)
        - [1.5.2. MyISAM存储引擎](#152-myisam%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)
        - [1.5.3. MySQL内建的其他存储引擎](#153-mysql%E5%86%85%E5%BB%BA%E7%9A%84%E5%85%B6%E4%BB%96%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)
        - [1.5.4. 第三方存储引擎](#154-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E)
        - [1.5.5. 选择合适的引擎](#155-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%BC%95%E6%93%8E)
        - [1.5.6. 转换表的引擎](#156-%E8%BD%AC%E6%8D%A2%E8%A1%A8%E7%9A%84%E5%BC%95%E6%93%8E)
    - [1.6. MySQl时间线（Timeline）](#16-mysql%E6%97%B6%E9%97%B4%E7%BA%BF%EF%BC%88timeline%EF%BC%89)
    - [1.7. MySQL的开发模式](#17-mysql%E7%9A%84%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F)
    - [1.8. 总结](#18-%E6%80%BB%E7%BB%93)
- [2. MySQL基准测试](#2-mysql%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95)
    - [2.1. 为什么需要基准测试](#21-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95)
    - [2.2. 基准测试的策略](#22-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%9A%84%E7%AD%96%E7%95%A5)
        - [2.2.1. 测试何种指标](#221-%E6%B5%8B%E8%AF%95%E4%BD%95%E7%A7%8D%E6%8C%87%E6%A0%87)
    - [2.3. 基准测试方法](#23-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95)
        - [2.3.1. 设计和规划基准测试](#231-%E8%AE%BE%E8%AE%A1%E5%92%8C%E8%A7%84%E5%88%92%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95)
        - [2.3.2. 基准测试该运行多长时间](#232-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E8%AF%A5%E8%BF%90%E8%A1%8C%E5%A4%9A%E9%95%BF%E6%97%B6%E9%97%B4)
        - [2.3.3. 获取系统性能和状态](#233-%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%92%8C%E7%8A%B6%E6%80%81)
        - [2.3.4. 获得准确的测试结果](#234-%E8%8E%B7%E5%BE%97%E5%87%86%E7%A1%AE%E7%9A%84%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C)
        - [2.3.5. 运行基准测试并分析结果](#235-%E8%BF%90%E8%A1%8C%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B9%B6%E5%88%86%E6%9E%90%E7%BB%93%E6%9E%9C)
        - [2.3.6. 绘图的重要性](#236-%E7%BB%98%E5%9B%BE%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7)
    - [2.4. 基准测试工具](#24-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7)
        - [2.4.1. 集成式测试工具](#241-%E9%9B%86%E6%88%90%E5%BC%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7)
        - [2.4.2. 单组件式测试工具](#242-%E5%8D%95%E7%BB%84%E4%BB%B6%E5%BC%8F%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7)
    - [2.5. 基准测试案例](#25-%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E6%A1%88%E4%BE%8B)
        - [2.5.1. http_load](#251-httpload)
        - [2.5.2. MySQL基准测试套件](#252-mysql%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E5%A5%97%E4%BB%B6)
        - [2.5.3. sysbench](#253-sysbench)
        - [2.5.4. 数据库测试套件中的dbt2 TPC-C测试](#254-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%8B%E8%AF%95%E5%A5%97%E4%BB%B6%E4%B8%AD%E7%9A%84dbt2-tpc-c%E6%B5%8B%E8%AF%95)
        - [2.5.5. Percona的TPCC-MySQL测试工具](#255-percona%E7%9A%84tpcc-mysql%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7)
    - [2.6. 总结](#26-%E6%80%BB%E7%BB%93)
- [3. 服务器性能剖析](#3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90)
    - [3.1. 性能优化简介](#31-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AE%80%E4%BB%8B)
        - [3.1.1. 通过性能剖析进行优化](#311-%E9%80%9A%E8%BF%87%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96)
        - [3.1.2. 理解性能剖析](#312-%E7%90%86%E8%A7%A3%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90)
    - [3.2. 对应用程序进行性能剖析](#32-%E5%AF%B9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%9B%E8%A1%8C%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90)
        - [3.2.1. 测量PHP应用程序](#321-%E6%B5%8B%E9%87%8Fphp%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)
    - [3.3. 剖析MySQL查询](#33-%E5%89%96%E6%9E%90mysql%E6%9F%A5%E8%AF%A2)
        - [3.3.1. 剖析服务器负载](#331-%E5%89%96%E6%9E%90%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%9F%E8%BD%BD)
        - [3.3.2. 剖析单条查询](#332-%E5%89%96%E6%9E%90%E5%8D%95%E6%9D%A1%E6%9F%A5%E8%AF%A2)
        - [3.3.3. 使用性能剖析](#333-%E4%BD%BF%E7%94%A8%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90)
    - [3.4. 诊断间歇性问题](#34-%E8%AF%8A%E6%96%AD%E9%97%B4%E6%AD%87%E6%80%A7%E9%97%AE%E9%A2%98)
        - [3.4.1. 单条查询问题还是服务器问题](#341-%E5%8D%95%E6%9D%A1%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98%E8%BF%98%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98)
        - [3.4.2. 捕获诊断数据](#342-%E6%8D%95%E8%8E%B7%E8%AF%8A%E6%96%AD%E6%95%B0%E6%8D%AE)
        - [3.4.3. 一个诊断案例](#343-%E4%B8%80%E4%B8%AA%E8%AF%8A%E6%96%AD%E6%A1%88%E4%BE%8B)
    - [3.5. 其他剖析工具](#35-%E5%85%B6%E4%BB%96%E5%89%96%E6%9E%90%E5%B7%A5%E5%85%B7)
        - [3.5.1. 使用USER_STATISTICS表](#351-%E4%BD%BF%E7%94%A8userstatistics%E8%A1%A8)
        - [3.5.2. 使用strace](#352-%E4%BD%BF%E7%94%A8strace)
    - [3.6. 总结](#36-%E6%80%BB%E7%BB%93)
- [4. Schema与数据类型优化](#4-schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96)
    - [4.1. 选择优化的数据类型](#41-%E9%80%89%E6%8B%A9%E4%BC%98%E5%8C%96%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)
            - [4.1.0.1. 更小的通常更好](#4101-%E6%9B%B4%E5%B0%8F%E7%9A%84%E9%80%9A%E5%B8%B8%E6%9B%B4%E5%A5%BD)
            - [4.1.0.2. 简单就好](#4102-%E7%AE%80%E5%8D%95%E5%B0%B1%E5%A5%BD)
            - [4.1.0.3. 尽量避免NULL](#4103-%E5%B0%BD%E9%87%8F%E9%81%BF%E5%85%8Dnull)
        - [4.1.1. 整数类型（TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT）](#411-%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%88tinyint%E3%80%81smallint%E3%80%81mediumint%E3%80%81int%E3%80%81bigint%EF%BC%89)
        - [4.1.2. 实数类型](#412-%E5%AE%9E%E6%95%B0%E7%B1%BB%E5%9E%8B)
        - [4.1.3. 字符串类型](#413-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B)
            - [4.1.3.1. VARCHAR和CHAR类型](#4131-varchar%E5%92%8Cchar%E7%B1%BB%E5%9E%8B)
                - [4.1.3.1.1. VARCHAR](#41311-varchar)
                - [4.1.3.1.2. CHAR（空格进行填充）](#41312-char%EF%BC%88%E7%A9%BA%E6%A0%BC%E8%BF%9B%E8%A1%8C%E5%A1%AB%E5%85%85%EF%BC%89)
                - [4.1.3.1.3. BLOB和TEXT类型](#41313-blob%E5%92%8Ctext%E7%B1%BB%E5%9E%8B)
                - [4.1.3.1.4. 使用枚举(ENUM)代替字符串类型。](#41314-%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BEenum%E4%BB%A3%E6%9B%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E3%80%82)
        - [4.1.4. 日期和时间类型](#414-%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B)
        - [4.1.5. 位数据类型](#415-%E4%BD%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)
            - [4.1.5.1. BIT](#4151-bit)
            - [4.1.5.2. SET](#4152-set)
        - [4.1.6. 选择标识符（identifier）](#416-%E9%80%89%E6%8B%A9%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%88identifier%EF%BC%89)
        - [4.1.7. 特殊类型数据](#417-%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE)
    - [4.2. MySQl schema设计中的陷阱](#42-mysql-schema%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E9%99%B7%E9%98%B1)
            - [4.2.0.1. 太多的列](#4201-%E5%A4%AA%E5%A4%9A%E7%9A%84%E5%88%97)
            - [4.2.0.2. 太多的关联](#4202-%E5%A4%AA%E5%A4%9A%E7%9A%84%E5%85%B3%E8%81%94)
            - [4.2.0.3. 全能的枚举](#4203-%E5%85%A8%E8%83%BD%E7%9A%84%E6%9E%9A%E4%B8%BE)
            - [4.2.0.4. 变相的枚举](#4204-%E5%8F%98%E7%9B%B8%E7%9A%84%E6%9E%9A%E4%B8%BE)
            - [4.2.0.5. 非此发明（Not Invent Here）的NULL](#4205-%E9%9D%9E%E6%AD%A4%E5%8F%91%E6%98%8E%EF%BC%88not-invent-here%EF%BC%89%E7%9A%84null)
    - [4.3. 范式和反范式](#43-%E8%8C%83%E5%BC%8F%E5%92%8C%E5%8F%8D%E8%8C%83%E5%BC%8F)
        - [4.3.1. 范式的优点和缺点](#431-%E8%8C%83%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9)
        - [4.3.2. 反范式的优点和缺点](#432-%E5%8F%8D%E8%8C%83%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9)
        - [4.3.3. 混用范式化和反范式化](#433-%E6%B7%B7%E7%94%A8%E8%8C%83%E5%BC%8F%E5%8C%96%E5%92%8C%E5%8F%8D%E8%8C%83%E5%BC%8F%E5%8C%96)
    - [4.4. 缓存表和汇总表](#44-%E7%BC%93%E5%AD%98%E8%A1%A8%E5%92%8C%E6%B1%87%E6%80%BB%E8%A1%A8)
        - [4.4.1. 物化视图](#441-%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE)
        - [4.4.2. 计数器表](#442-%E8%AE%A1%E6%95%B0%E5%99%A8%E8%A1%A8)
    - [4.5. 加快ALTER TABLE操作的速度](#45-%E5%8A%A0%E5%BF%ABalter-table%E6%93%8D%E4%BD%9C%E7%9A%84%E9%80%9F%E5%BA%A6)
        - [4.5.1. 只修改.frm文件](#451-%E5%8F%AA%E4%BF%AE%E6%94%B9frm%E6%96%87%E4%BB%B6)
        - [4.5.2. 快速创建MyISAM索引](#452-%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BAmyisam%E7%B4%A2%E5%BC%95)
    - [4.6. 总结](#46-%E6%80%BB%E7%BB%93)
- [5. 创建高性能索引](#5-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95)
    - [5.1. 索引基础](#51-%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80)
        - [5.1.1. 索引的类型](#511-%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B)
            - [5.1.1.1. B-Tree索引](#5111-b-tree%E7%B4%A2%E5%BC%95)
                - [5.1.1.1.1. 可以使用B-Tree索引的查询类型](#51111-%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8b-tree%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9F%A5%E8%AF%A2%E7%B1%BB%E5%9E%8B)
            - [5.1.1.2. 哈希索引](#5112-%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95)
            - [5.1.1.3. 空间数据索引](#5113-%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95)
            - [5.1.1.4. 全文索引](#5114-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95)
    - [5.2. 索引的优点](#52-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9)
    - [5.3. 高性能的索引策略](#53-%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95%E7%AD%96%E7%95%A5)
        - [5.3.1. 独立的列](#531-%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%88%97)
        - [5.3.2. 前缀索引和索引选择性](#532-%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E6%80%A7)
        - [5.3.3. 多列索引](#533-%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95)
        - [5.3.4. 选择合适的索引列排序](#534-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%B4%A2%E5%BC%95%E5%88%97%E6%8E%92%E5%BA%8F)
        - [5.3.5. 聚簇索引](#535-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95)
            - [5.3.5.1. ）InnoDB和MyISAM的数据分布对比](#5351-%EF%BC%89innodb%E5%92%8Cmyisam%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E5%AF%B9%E6%AF%94)
                - [5.3.5.1.1. MyISAM的数据分布](#53511-myisam%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83)
                - [5.3.5.1.2. InnoDB的数据分布](#53512-innodb%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83)
            - [5.3.5.2. ) 在InnoDB中按主键顺序插入行](#5352-%E5%9C%A8innodb%E4%B8%AD%E6%8C%89%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5%E8%A1%8C)
        - [5.3.6. 覆盖索引](#536-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95)
                - [5.3.6.0.1. type列和Extra列的区别：type列表示查询访问数据的方式（join type），Extra列表示是否使用覆盖索引。](#53601-type%E5%88%97%E5%92%8Cextra%E5%88%97%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9Atype%E5%88%97%E8%A1%A8%E7%A4%BA%E6%9F%A5%E8%AF%A2%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%88join-type%EF%BC%89%EF%BC%8Cextra%E5%88%97%E8%A1%A8%E7%A4%BA%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E3%80%82)
                - [5.3.6.0.2. 延迟关联（deferred join）](#53602-%E5%BB%B6%E8%BF%9F%E5%85%B3%E8%81%94%EF%BC%88deferred-join%EF%BC%89)
        - [5.3.7. 使用索引扫描来做排序](#537-%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%89%AB%E6%8F%8F%E6%9D%A5%E5%81%9A%E6%8E%92%E5%BA%8F)
        - [5.3.8. 压缩（前缀压缩）索引（MyISAM）](#538-%E5%8E%8B%E7%BC%A9%EF%BC%88%E5%89%8D%E7%BC%80%E5%8E%8B%E7%BC%A9%EF%BC%89%E7%B4%A2%E5%BC%95%EF%BC%88myisam%EF%BC%89)
            - [5.3.8.1. 背景](#5381-%E8%83%8C%E6%99%AF)
            - [5.3.8.2. 方法](#5382-%E6%96%B9%E6%B3%95)
            - [5.3.8.3. 缺点](#5383-%E7%BC%BA%E7%82%B9)
            - [5.3.8.4. 结论](#5384-%E7%BB%93%E8%AE%BA)
        - [5.3.9. 冗余和重复索引](#539-%E5%86%97%E4%BD%99%E5%92%8C%E9%87%8D%E5%A4%8D%E7%B4%A2%E5%BC%95)
        - [5.3.10. 未使用的索引](#5310-%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B4%A2%E5%BC%95)
        - [5.3.11. 索引和锁](#5311-%E7%B4%A2%E5%BC%95%E5%92%8C%E9%94%81)
    - [5.4. 索引案例学习](#54-%E7%B4%A2%E5%BC%95%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0)
        - [5.4.1. 支持多种过滤条件](#541-%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E8%BF%87%E6%BB%A4%E6%9D%A1%E4%BB%B6)
        - [5.4.2. 避免多个范围条件](#542-%E9%81%BF%E5%85%8D%E5%A4%9A%E4%B8%AA%E8%8C%83%E5%9B%B4%E6%9D%A1%E4%BB%B6)
        - [5.4.3. 优化排序](#543-%E4%BC%98%E5%8C%96%E6%8E%92%E5%BA%8F)
    - [5.5. 维护索引和表](#55-%E7%BB%B4%E6%8A%A4%E7%B4%A2%E5%BC%95%E5%92%8C%E8%A1%A8)
        - [5.5.1. 找到并修复损坏的表](#551-%E6%89%BE%E5%88%B0%E5%B9%B6%E4%BF%AE%E5%A4%8D%E6%8D%9F%E5%9D%8F%E7%9A%84%E8%A1%A8)
        - [5.5.2. 更新索引统计信息](#552-%E6%9B%B4%E6%96%B0%E7%B4%A2%E5%BC%95%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF)
        - [5.5.3. 减少索引和数据的碎片](#553-%E5%87%8F%E5%B0%91%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E7%A2%8E%E7%89%87)
    - [5.6. 总结](#56-%E6%80%BB%E7%BB%93)
- [6. 查询性能优化](#6-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96)
    - [6.1. 为什么查询速度会慢](#61-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%E4%BC%9A%E6%85%A2)
    - [6.2. 慢查询基础：优化数据访问](#62-%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE)
        - [6.2.1. 是否向数据库请求了不需要的列](#621-%E6%98%AF%E5%90%A6%E5%90%91%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%B7%E6%B1%82%E4%BA%86%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%E5%88%97)
        - [6.2.2. MySQL是否在扫描额外的记录](#622-mysql%E6%98%AF%E5%90%A6%E5%9C%A8%E6%89%AB%E6%8F%8F%E9%A2%9D%E5%A4%96%E7%9A%84%E8%AE%B0%E5%BD%95)
            - [6.2.2.1. 响应时间](#6221-%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4)
            - [6.2.2.2. 扫描的行数和返回的行数](#6222-%E6%89%AB%E6%8F%8F%E7%9A%84%E8%A1%8C%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E7%9A%84%E8%A1%8C%E6%95%B0)
            - [6.2.2.3. 扫描的行数和访问类型](#6223-%E6%89%AB%E6%8F%8F%E7%9A%84%E8%A1%8C%E6%95%B0%E5%92%8C%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B)
            - [6.2.2.4. 应用where条件的方式](#6224-%E5%BA%94%E7%94%A8where%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F)
            - [6.2.2.5. 扫描大量数据只返回少数的行的解决方法](#6225-%E6%89%AB%E6%8F%8F%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%8F%AA%E8%BF%94%E5%9B%9E%E5%B0%91%E6%95%B0%E7%9A%84%E8%A1%8C%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95)
    - [6.3. 重构查询的方式](#63-%E9%87%8D%E6%9E%84%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F)
        - [6.3.1. 一个复杂的查询还是多个简单的查询](#631-%E4%B8%80%E4%B8%AA%E5%A4%8D%E6%9D%82%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%98%E6%98%AF%E5%A4%9A%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%9F%A5%E8%AF%A2)
        - [6.3.2. 切分查询](#632-%E5%88%87%E5%88%86%E6%9F%A5%E8%AF%A2)
        - [6.3.3. 分解关联查询](#633-%E5%88%86%E8%A7%A3%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2)
    - [6.4. 执行查询的基础](#64-%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%9F%BA%E7%A1%80)
        - [6.4.1. MySQl客户端/服务器通信协议](#641-mysql%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE)
            - [6.4.1.1. 查询状态](#6411-%E6%9F%A5%E8%AF%A2%E7%8A%B6%E6%80%81)
        - [6.4.2. 查询缓存](#642-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98)
        - [6.4.3. 查询优化处理](#643-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%A4%84%E7%90%86)
        - [6.4.4. 查询执行引擎](#644-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E)
        - [6.4.5. 返回结果给客户端](#645-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF)
    - [6.5. MySQL查询优化器的局限性](#65-mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7)
        - [6.5.1. 关联子查询](#651-%E5%85%B3%E8%81%94%E5%AD%90%E6%9F%A5%E8%AF%A2)
        - [6.5.2. UNION的限制](#652-union%E7%9A%84%E9%99%90%E5%88%B6)
        - [6.5.3. 索引合并优化](#653-%E7%B4%A2%E5%BC%95%E5%90%88%E5%B9%B6%E4%BC%98%E5%8C%96)
        - [6.5.4. 等值传递](#654-%E7%AD%89%E5%80%BC%E4%BC%A0%E9%80%92)
        - [6.5.5. 并行执行](#655-%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C)
        - [6.5.6. 哈希关联](#656-%E5%93%88%E5%B8%8C%E5%85%B3%E8%81%94)
        - [6.5.7. 松散索引扫描](#657-%E6%9D%BE%E6%95%A3%E7%B4%A2%E5%BC%95%E6%89%AB%E6%8F%8F)
        - [6.5.8. 最大值和最小值优化](#658-%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC%E4%BC%98%E5%8C%96)
        - [6.5.9. 在同一个表上查询和更新](#659-%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E8%A1%A8%E4%B8%8A%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%9B%B4%E6%96%B0)
    - [6.6. 查询优化器的提示（hint）](#66-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E7%9A%84%E6%8F%90%E7%A4%BA%EF%BC%88hint%EF%BC%89)
    - [6.7. 优化特定类型的查询](#67-%E4%BC%98%E5%8C%96%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9F%A5%E8%AF%A2)
        - [6.7.1. 优化COUNT()查询](#671-%E4%BC%98%E5%8C%96count%E6%9F%A5%E8%AF%A2)
        - [6.7.2. 优化关联查询](#672-%E4%BC%98%E5%8C%96%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2)
        - [6.7.3. 优化子查询](#673-%E4%BC%98%E5%8C%96%E5%AD%90%E6%9F%A5%E8%AF%A2)
        - [6.7.4. 优化GROUP BY和DESTINCT](#674-%E4%BC%98%E5%8C%96group-by%E5%92%8Cdestinct)
        - [6.7.5. 优化LIMIT分页](#675-%E4%BC%98%E5%8C%96limit%E5%88%86%E9%A1%B5)
        - [6.7.6. 优化SQL_CALC_FOUND_ROWS](#676-%E4%BC%98%E5%8C%96sqlcalcfoundrows)
        - [6.7.7. 优化UNION查询](#677-%E4%BC%98%E5%8C%96union%E6%9F%A5%E8%AF%A2)
        - [6.7.8. 静态查询分析](#678-%E9%9D%99%E6%80%81%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90)
        - [6.7.9. 使用用户自定义变量](#679-%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F)
    - [6.8. 案例学习](#68-%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0)
        - [6.8.1. 使用MySQL构建一个队列表](#681-%E4%BD%BF%E7%94%A8mysql%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97%E8%A1%A8)
        - [6.8.2. 计算两点之间的距离](#682-%E8%AE%A1%E7%AE%97%E4%B8%A4%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB)
        - [6.8.3. 使用用户自定义函数](#683-%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0)
    - [6.9. 总结](#69-%E6%80%BB%E7%BB%93)
- [7. MySQL高级特性](#7-mysql%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7)
    - [7.1. 分区表](#71-%E5%88%86%E5%8C%BA%E8%A1%A8)
    - [7.2. 视图](#72-%E8%A7%86%E5%9B%BE)
        - [7.2.1. 可更新视图](#721-%E5%8F%AF%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE)
        - [7.2.2. 视图对性能的影响](#722-%E8%A7%86%E5%9B%BE%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D)
        - [7.2.3. 视图的限制](#723-%E8%A7%86%E5%9B%BE%E7%9A%84%E9%99%90%E5%88%B6)
    - [7.3. 外键约束](#73-%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F)
    - [7.4. 在MySQL内部存储代码](#74-%E5%9C%A8mysql%E5%86%85%E9%83%A8%E5%AD%98%E5%82%A8%E4%BB%A3%E7%A0%81)
        - [7.4.1. 存储过程和函数](#741-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0)
        - [7.4.2. 触发器](#742-%E8%A7%A6%E5%8F%91%E5%99%A8)
        - [7.4.3. 事件](#743-%E4%BA%8B%E4%BB%B6)
        - [7.4.4. 在存储过程中保留注释](#744-%E5%9C%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BF%9D%E7%95%99%E6%B3%A8%E9%87%8A)
    - [7.5. 游标](#75-%E6%B8%B8%E6%A0%87)
    - [7.6. 绑定变量](#76-%E7%BB%91%E5%AE%9A%E5%8F%98%E9%87%8F)
        - [7.6.1. 绑定变量的优化](#761-%E7%BB%91%E5%AE%9A%E5%8F%98%E9%87%8F%E7%9A%84%E4%BC%98%E5%8C%96)
        - [7.6.2. SQL接口的绑定变量](#762-sql%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%91%E5%AE%9A%E5%8F%98%E9%87%8F)
        - [7.6.3. 绑定变量的限制](#763-%E7%BB%91%E5%AE%9A%E5%8F%98%E9%87%8F%E7%9A%84%E9%99%90%E5%88%B6)
    - [7.7. 用户自定义函数](#77-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0)
    - [7.8. 插件](#78-%E6%8F%92%E4%BB%B6)
    - [7.9. 字符集和校对](#79-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%A0%A1%E5%AF%B9)
        - [7.9.1. MySQL如何使用字符集](#791-mysql%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E9%9B%86)
        - [7.9.2. 选择字符集和校对规则](#792-%E9%80%89%E6%8B%A9%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%A0%A1%E5%AF%B9%E8%A7%84%E5%88%99)
        - [7.9.3. 字符集和校对规则如何影响查询](#793-%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%A0%A1%E5%AF%B9%E8%A7%84%E5%88%99%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E6%9F%A5%E8%AF%A2)
    - [7.10. 全文索引](#710-%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95)
    - [7.11. 分布式（XA）事务](#711-%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%88xa%EF%BC%89%E4%BA%8B%E5%8A%A1)
    - [7.12. 查询缓存](#712-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98)
    - [7.13. 总结](#713-%E6%80%BB%E7%BB%93)
- [8. 优化服务器设置](#8-%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE)
    - [8.1. MySQL配置的工作原理](#81-mysql%E9%85%8D%E7%BD%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)
    - [8.2. 什么不该做](#82-%E4%BB%80%E4%B9%88%E4%B8%8D%E8%AF%A5%E5%81%9A)
    - [8.3. 创建MySQL配置文件](#83-%E5%88%9B%E5%BB%BAmysql%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6)
        - [8.3.1. 检查MySQL服务器状态变量](#831-%E6%A3%80%E6%9F%A5mysql%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F)
    - [8.4. 配置内存使用](#84-%E9%85%8D%E7%BD%AE%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8)
        - [8.4.1. MySQL可以使用多少内存](#841-mysql%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98)
        - [8.4.2. 每个连接需要的内存](#842-%E6%AF%8F%E4%B8%AA%E8%BF%9E%E6%8E%A5%E9%9C%80%E8%A6%81%E7%9A%84%E5%86%85%E5%AD%98)
        - [8.4.3. 为操作系统保留内存](#843-%E4%B8%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BF%9D%E7%95%99%E5%86%85%E5%AD%98)
        - [8.4.4. 为缓存分配内存](#844-%E4%B8%BA%E7%BC%93%E5%AD%98%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98)
        - [8.4.5. InnoDB缓冲池（Buffer Pool）](#845-innodb%E7%BC%93%E5%86%B2%E6%B1%A0%EF%BC%88buffer-pool%EF%BC%89)
        - [8.4.6. MyISAM键缓存（Key Caches）](#846-myisam%E9%94%AE%E7%BC%93%E5%AD%98%EF%BC%88key-caches%EF%BC%89)
        - [8.4.7. 线程缓存](#847-%E7%BA%BF%E7%A8%8B%E7%BC%93%E5%AD%98)
        - [8.4.8. 表缓存（Table Cache）](#848-%E8%A1%A8%E7%BC%93%E5%AD%98%EF%BC%88table-cache%EF%BC%89)
        - [8.4.9. InnoDB数据字典（Data Dictionary）](#849-innodb%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8%EF%BC%88data-dictionary%EF%BC%89)
    - [8.5. 配置MySQL的I/O行为](#85-%E9%85%8D%E7%BD%AEmysql%E7%9A%84io%E8%A1%8C%E4%B8%BA)
        - [8.5.1. InnoDB I/O配置](#851-innodb-io%E9%85%8D%E7%BD%AE)
        - [8.5.2. MyISAM的I/O配置](#852-myisam%E7%9A%84io%E9%85%8D%E7%BD%AE)
    - [8.6. 配置MySQL并发](#86-%E9%85%8D%E7%BD%AEmysql%E5%B9%B6%E5%8F%91)
        - [8.6.1. InnoDB的并发配置](#861-innodb%E7%9A%84%E5%B9%B6%E5%8F%91%E9%85%8D%E7%BD%AE)
        - [8.6.2. MyISAM并发配置](#862-myisam%E5%B9%B6%E5%8F%91%E9%85%8D%E7%BD%AE)
    - [8.7. 基于工作负载的配置](#87-%E5%9F%BA%E4%BA%8E%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E7%9A%84%E9%85%8D%E7%BD%AE)
        - [8.7.1. 优化BLOB和TEXT的场景](#871-%E4%BC%98%E5%8C%96blob%E5%92%8Ctext%E7%9A%84%E5%9C%BA%E6%99%AF)
        - [8.7.2. 优化排序（Filesorts）](#872-%E4%BC%98%E5%8C%96%E6%8E%92%E5%BA%8F%EF%BC%88filesorts%EF%BC%89)
    - [8.8. 完成基本配置](#88-%E5%AE%8C%E6%88%90%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE)
    - [8.9. 安全和稳定的配置](#89-%E5%AE%89%E5%85%A8%E5%92%8C%E7%A8%B3%E5%AE%9A%E7%9A%84%E9%85%8D%E7%BD%AE)
    - [8.10. 高级InnoDB设置](#810-%E9%AB%98%E7%BA%A7innodb%E8%AE%BE%E7%BD%AE)
    - [8.11. 总结](#811-%E6%80%BB%E7%BB%93)
- [9. 操作系统和硬件优化](#9-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%96)
    - [9.1. 什么限制了MySQL的性能](#91-%E4%BB%80%E4%B9%88%E9%99%90%E5%88%B6%E4%BA%86mysql%E7%9A%84%E6%80%A7%E8%83%BD)
    - [9.2. 如何为MySQL选择CPU](#92-%E5%A6%82%E4%BD%95%E4%B8%BAmysql%E9%80%89%E6%8B%A9cpu)
    - [9.3. 平衡内存和磁盘资源](#93-%E5%B9%B3%E8%A1%A1%E5%86%85%E5%AD%98%E5%92%8C%E7%A3%81%E7%9B%98%E8%B5%84%E6%BA%90)
    - [9.4. 固态存储](#94-%E5%9B%BA%E6%80%81%E5%AD%98%E5%82%A8)
    - [9.5. 为备库选择硬件](#95-%E4%B8%BA%E5%A4%87%E5%BA%93%E9%80%89%E6%8B%A9%E7%A1%AC%E4%BB%B6)
    - [9.6. RAID性能优化](#96-raid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96)
    - [9.7. SAN和NAS](#97-san%E5%92%8Cnas)
    - [9.8. 使用多磁盘卷](#98-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%A3%81%E7%9B%98%E5%8D%B7)
    - [9.9. 网络配置](#99-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE)
    - [9.10. 选择操作系统](#910-%E9%80%89%E6%8B%A9%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)
    - [9.11. 选择文件系统](#911-%E9%80%89%E6%8B%A9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F)
    - [9.12. 选择磁盘队列调度策略](#912-%E9%80%89%E6%8B%A9%E7%A3%81%E7%9B%98%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5)
    - [9.13. 线程](#913-%E7%BA%BF%E7%A8%8B)
    - [9.14. 内存交换区](#914-%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E5%8C%BA)
    - [9.15. 操作系统状态](#915-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%8A%B6%E6%80%81)
    - [9.16. 总结](#916-%E6%80%BB%E7%BB%93)
- [10. 复制](#10-%E5%A4%8D%E5%88%B6)
    - [10.1. 复制概述](#101-%E5%A4%8D%E5%88%B6%E6%A6%82%E8%BF%B0)
    - [10.2. 配置复制](#102-%E9%85%8D%E7%BD%AE%E5%A4%8D%E5%88%B6)
    - [10.3. 复制的原理](#103-%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86)
    - [10.4. 复制拓扑](#104-%E5%A4%8D%E5%88%B6%E6%8B%93%E6%89%91)
    - [10.5. 复制和容量规划](#105-%E5%A4%8D%E5%88%B6%E5%92%8C%E5%AE%B9%E9%87%8F%E8%A7%84%E5%88%92)
    - [10.6. 复制管理和维护](#106-%E5%A4%8D%E5%88%B6%E7%AE%A1%E7%90%86%E5%92%8C%E7%BB%B4%E6%8A%A4)
    - [10.7. 复制的问题和解决方案](#107-%E5%A4%8D%E5%88%B6%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88)
    - [10.8. 复制有多快](#108-%E5%A4%8D%E5%88%B6%E6%9C%89%E5%A4%9A%E5%BF%AB)
    - [10.9. MySQL复制的高级特性](#109-mysql%E5%A4%8D%E5%88%B6%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7)
    - [10.10. 其他复制技术](#1010-%E5%85%B6%E4%BB%96%E5%A4%8D%E5%88%B6%E6%8A%80%E6%9C%AF)
    - [10.11. 总结](#1011-%E6%80%BB%E7%BB%93)
- [11. 可扩展的MySQL](#11-%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84mysql)
    - [11.1. 什么是可扩展性](#111-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7)
    - [11.2. 扩展MySQL](#112-%E6%89%A9%E5%B1%95mysql)
    - [11.3. 负载均衡](#113-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1)
    - [11.4. 总结](#114-%E6%80%BB%E7%BB%93)
- [12. 高可用性](#12-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7)
    - [12.1. 什么是高可用性](#121-%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7)
    - [12.2. 导致宕机的原因](#122-%E5%AF%BC%E8%87%B4%E5%AE%95%E6%9C%BA%E7%9A%84%E5%8E%9F%E5%9B%A0)
    - [12.3. 如何实现高可用性](#123-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7)
    - [12.4. 避免单点失效](#124-%E9%81%BF%E5%85%8D%E5%8D%95%E7%82%B9%E5%A4%B1%E6%95%88)
    - [12.5. 故障转移和故障恢复](#125-%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E5%92%8C%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D)
    - [12.6. 总结](#126-%E6%80%BB%E7%BB%93)
- [13. 云端的MySQL](#13-%E4%BA%91%E7%AB%AF%E7%9A%84mysql)
    - [13.1. 云的优点、缺点和相关误解](#131-%E4%BA%91%E7%9A%84%E4%BC%98%E7%82%B9%E3%80%81%E7%BC%BA%E7%82%B9%E5%92%8C%E7%9B%B8%E5%85%B3%E8%AF%AF%E8%A7%A3)
    - [13.2. MySQL 在云端的经济价值](#132-mysql-%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%9A%84%E7%BB%8F%E6%B5%8E%E4%BB%B7%E5%80%BC)
    - [13.3. 云中的MySQL 的可扩展性和高可用性](#133-%E4%BA%91%E4%B8%AD%E7%9A%84mysql-%E7%9A%84%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7)
    - [13.4. 四种基础资源](#134-%E5%9B%9B%E7%A7%8D%E5%9F%BA%E7%A1%80%E8%B5%84%E6%BA%90)
    - [13.5. MySQL 在云主机上的性能](#135-mysql-%E5%9C%A8%E4%BA%91%E4%B8%BB%E6%9C%BA%E4%B8%8A%E7%9A%84%E6%80%A7%E8%83%BD)
    - [13.6. MySQL 数据库即服务（DBaaS）](#136-mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%B3%E6%9C%8D%E5%8A%A1%EF%BC%88dbaas%EF%BC%89)
    - [13.7. 总结](#137-%E6%80%BB%E7%BB%93)
- [14. 应用层优化](#14-%E5%BA%94%E7%94%A8%E5%B1%82%E4%BC%98%E5%8C%96)
    - [14.1. 常见问题](#141-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98)
    - [14.2. Web 服务器问题](#142-web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98)
    - [14.3. 缓存](#143-%E7%BC%93%E5%AD%98)
    - [14.4. 拓展MySQL](#144-%E6%8B%93%E5%B1%95mysql)
    - [14.5. MySQL的替代产品](#145-mysql%E7%9A%84%E6%9B%BF%E4%BB%A3%E4%BA%A7%E5%93%81)
    - [14.6. 总结](#146-%E6%80%BB%E7%BB%93)
- [15. 备份和恢复](#15-%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D)
    - [15.1. 为什么要备份](#151-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A4%87%E4%BB%BD)
    - [15.2. 定义恢复需求](#152-%E5%AE%9A%E4%B9%89%E6%81%A2%E5%A4%8D%E9%9C%80%E6%B1%82)
    - [15.3. 设计MySQL备份方案](#153-%E8%AE%BE%E8%AE%A1mysql%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88)
    - [15.4. 管理和备份二进制日志](#154-%E7%AE%A1%E7%90%86%E5%92%8C%E5%A4%87%E4%BB%BD%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97)
    - [15.5. 备份数据](#155-%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE)
    - [15.6. 从备份中恢复](#156-%E4%BB%8E%E5%A4%87%E4%BB%BD%E4%B8%AD%E6%81%A2%E5%A4%8D)
    - [15.7. 备份和恢复工具](#157-%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D%E5%B7%A5%E5%85%B7)
    - [15.8. 备份脚本化](#158-%E5%A4%87%E4%BB%BD%E8%84%9A%E6%9C%AC%E5%8C%96)
    - [15.9. 总结](#159-%E6%80%BB%E7%BB%93)
- [16. MySQL用户工具](#16-mysql%E7%94%A8%E6%88%B7%E5%B7%A5%E5%85%B7)
    - [16.1. 接口工具](#161-%E6%8E%A5%E5%8F%A3%E5%B7%A5%E5%85%B7)
    - [16.2. 命令行工具集](#162-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E9%9B%86)
    - [16.3. SQL实用集](#163-sql%E5%AE%9E%E7%94%A8%E9%9B%86)
    - [16.4. 监测工具](#164-%E7%9B%91%E6%B5%8B%E5%B7%A5%E5%85%B7)
    - [16.5. 总结](#165-%E6%80%BB%E7%BB%93)

<!-- /TOC -->
# 1. MySQL架构与历史
## 1.1. MySQL逻辑架构
### 1.1.1. 连接管理与安全性
### 1.1.2. 优化与执行
## 1.2. 并发控制
### 1.2.1. 读写锁
### 1.2.2. 锁粒度
## 1.3. 事务
### 1.3.1. 隔离级别
### 1.3.2. 死锁
### 1.3.3. 事务日志
### 1.3.4. MySQL中的事务
## 1.4. 多版本并发控制
## 1.5. MySQl的存储引擎
### 1.5.1. InnoDB存储引擎
### 1.5.2. MyISAM存储引擎
### 1.5.3. MySQL内建的其他存储引擎
### 1.5.4. 第三方存储引擎
### 1.5.5. 选择合适的引擎
### 1.5.6. 转换表的引擎
## 1.6. MySQl时间线（Timeline）
## 1.7. MySQL的开发模式
## 1.8. 总结
# 2. MySQL基准测试
## 2.1. 为什么需要基准测试
## 2.2. 基准测试的策略
### 2.2.1. 测试何种指标
## 2.3. 基准测试方法
### 2.3.1. 设计和规划基准测试
### 2.3.2. 基准测试该运行多长时间
### 2.3.3. 获取系统性能和状态
### 2.3.4. 获得准确的测试结果
### 2.3.5. 运行基准测试并分析结果
### 2.3.6. 绘图的重要性
## 2.4. 基准测试工具
### 2.4.1. 集成式测试工具
### 2.4.2. 单组件式测试工具
## 2.5. 基准测试案例
### 2.5.1. http_load
### 2.5.2. MySQL基准测试套件
### 2.5.3. sysbench
### 2.5.4. 数据库测试套件中的dbt2 TPC-C测试
### 2.5.5. Percona的TPCC-MySQL测试工具
## 2.6. 总结
# 3. 服务器性能剖析
## 3.1. 性能优化简介
### 3.1.1. 通过性能剖析进行优化
### 3.1.2. 理解性能剖析
## 3.2. 对应用程序进行性能剖析
### 3.2.1. 测量PHP应用程序
## 3.3. 剖析MySQL查询
### 3.3.1. 剖析服务器负载
### 3.3.2. 剖析单条查询
### 3.3.3. 使用性能剖析
## 3.4. 诊断间歇性问题
### 3.4.1. 单条查询问题还是服务器问题
### 3.4.2. 捕获诊断数据
### 3.4.3. 一个诊断案例
## 3.5. 其他剖析工具
### 3.5.1. 使用USER_STATISTICS表
### 3.5.2. 使用strace
## 3.6. 总结
# 4. Schema与数据类型优化
根据系统将要执行的查询语句来设计Schema。
## 4.1. 选择优化的数据类型
#### 4.1.0.1. 更小的通常更好
应尽量使用可以正确存储数据的最小数据类型。

确保没有低估需要存储的值得范围。（在Schema中的多个地方增加数据类型的范围是一个非常耗时和痛苦的工作）
#### 4.1.0.2. 简单就好
简单数据类型的操作通常需要更少的CPU周期。

用整型存储IP地址。
#### 4.1.0.3. 尽量避免NULL
可为NULL的列使得索引、索引统计和值比较都会变得复杂。

InnoDB使用单独的位（bit）存储NULL值，所以对稀疏数据有很好的空间效率。但是不适用于MyISAM。

TIMESTAMP只使用DATETIME一半的存储空间，并且会根据时区变化。但是允许的时间范围小。
### 4.1.1. 整数类型（TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT）
整数计算一般使用64位的BIGINT整数，即使在32位环境也是如此。
MySQL可以为整数指定宽度，例如INT(11)（不会限制值的合法范围，只是规定了交互工具用来显示字符的个数）。
### 4.1.2. 实数类型
定义：实数是带有小数部分的数字。但是不只是为了存储小数，也可以使用DECIMAL存储比BIGINT还大的整数。

1.  MySQL既支持精确类型，也支持不精确类型。

2.  CPU支持原生浮点类型，不支持DECIMAL类型，所以原生浮点类型运算更快。

3.  DECIMAL可以指定小数点前后允许的最大位数，例如DECIMAL(18,9)。（每4个字节存9个数字，小数点本身占一个字节）。

4.  MYSQL5.0后DECIMAL允许最多65个数字。

5.  在计算时DECIMAL会转换为DOUBLE类型。

6.  应尽量只在对小数进行精确计算时才使用DECIMAL。

### 4.1.3. 字符串类型
#### 4.1.3.1. VARCHAR和CHAR类型
##### 4.1.3.1.1. VARCHAR
1.  如果MySQL表使用ROW_FORMAT=FIXED创建的话，每一行都会使用定长存储。
2.  VARCHAR需要使用1或2个额外字节记录字符串的长度。（根据列的长度大于或小于255个字节区分）
3.  InnDB可以把过长的VARCHAR存储为BLOB。

##### 4.1.3.1.2. CHAR（空格进行填充）
1.  当存储CHAR值时，MySQL会删除所有的末尾空格。
2.  优点：定长的CHAR类型不容易产生碎片。
3.  字符串长度定义不是字节数，是字符数，多字节字符集会需要更多的空间存储单个字符。
4.  填充和截取空格的行为在不同的存储引擎都是一样的，因为这是在MySQL服务器层处理的。
5.  BINARY和VARBINARY存储二进制字符串，二进制字符串存储的是字节码而不是字符。（\0进行填充，检索时不会去掉）

##### 4.1.3.1.3. BLOB和TEXT类型
1.  为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。
2.  只对每个列最前max_sort_length字节而不是整个字符串做排序。

**如果EXPLAIN执行计划的Extra列包含“Using temporary”，则说明这个查询使用了隐式临时表。**
##### 4.1.3.1.4. 使用枚举(ENUM)代替字符串类型。
1.  MySQL会在内部将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的“查找表”。
2.  枚举字段是按照内部存储的整数而不是定义的字符串进行排序的。（按照需要的方式定义枚举列）
3.  对于一系列未来会改变的字符串，使用枚举不是一个好主意。

### 4.1.4. 日期和时间类型
除了特殊行为之外，通常应该尽量使用TIMESTAMP,因为它比DATATIME空间效率更高。
### 4.1.5. 位数据类型
#### 4.1.5.1. BIT
数字上下文场景异常，谨慎使用BIT类型。
#### 4.1.5.2. SET
SET数据类型在MySQL内部是以一系列打包的位的集合来表示的。
一个替代SET的方式是使用一个整数包装一系列的位。
### 4.1.6. 选择标识符（identifier）
在比较操作室隐式类型转换可能导致很难发现的错误。

随机值导致缓存对所有类型的查询语句效果都很差。

**对象关系映射（orm）系统是一种常见的性能噩梦。**

### 4.1.7. 特殊类型数据
ipv4：MySQL提供INET_ATON()和INET_NTOA()函数在点分法字符串和无符号整数之间转换。

## 4.2. MySQl schema设计中的陷阱
#### 4.2.0.1. 太多的列
MySQL存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。转换的代价依赖于列的数量。
#### 4.2.0.2. 太多的关联
#### 4.2.0.3. 全能的枚举
应该用整数作为外键关联到字典表或者查找表来查找具体值。（防止表结构的修改）
#### 4.2.0.4. 变相的枚举
如果每次只会出现一个值（Y或N），应使用枚举代替SET。
#### 4.2.0.5. 非此发明（Not Invent Here）的NULL
1.  处理NULL确实不容易，但有时会比他的替代方案更好。
2.  MySQL会在索引中存储NULL值，Oracle不会。

## 4.3. 范式和反范式
### 4.3.1. 范式的优点和缺点
优点：范式的表通常更小，可以更好地方在内存里，所以执行操作会更快。

缺点：通常需要关联。
### 4.3.2. 反范式的优点和缺点
单独的表能使用更高效的索引策略。
### 4.3.3. 混用范式化和反范式化
在不同的表中存储相同的特定列。

排序的需要。
## 4.4. 缓存表和汇总表
### 4.4.1. 物化视图
### 4.4.2. 计数器表

## 4.5. 加快ALTER TABLE操作的速度
1.  大部分ALTER TABLE操作将导致MySQL服务中断。
2.  ALTER TABLE允许使用ALTER COLUMN、MODIFY COLUMN和CHANGE COLUMN语句修改列。这三种操作都是不一样的。
3.  影子拷贝。（通过重命名和删表交换两张表）

### 4.5.1. 只修改.frm文件
执行FLUSH TABLES READ LOCK会关闭所有正在使用的表，并且禁止任何表被打开。

执行UNLOCK TABLE释放读锁。
### 4.5.2. 快速创建MyISAM索引
为了高效地载入数据到MyISAM表中，先禁用索引、载入数据，然后重新启用索引。
```
mysql> ALTER TABLE test.load_data DISABLE KEYS;
--load the data
mysql> ALTER TABLE test.load_data ENABLE KEYS;
```
DISABLE KEYS只对非唯一索引有效。

**InnoDB版本：先删除所有的非唯一索引，然后增加新的列，最后重新创建删除掉的索引。**
## 4.6. 总结
避免使用MySQL已经遗弃的特性，例如指定浮点数的精度，或者整数的显示宽度。
# 5. 创建高性能索引
**背景：不恰当使用索引，当数据量逐渐增大时，性能会急剧下降。**
## 5.1. 索引基础
如果索引包含多个列，那么列的顺序也十分重要，因为MySql只能高效地使用索引的最左前缀列。
**Tip：关于ORM框架：除非只是生成非常基本的查询（例如仅是根据主键查询），否则很难生成适合索引的查询。**
### 5.1.1. 索引的类型
在MySQL中，索引是在引擎层而不是在服务器层实现的。（并不是所有的引擎都支持索引）
#### 5.1.1.1. B-Tree索引
**Tip：很多存储引擎都是用的B+Tree，即每一个叶子节点都包含指向下一个叶子节点的指针。**
MyISAM索引通过数据的物理位置引用被索引的行；InnoDB则根据主键引用被索引的行（所以二级索引需要两次索引查找）。
##### 5.1.1.1.1. 可以使用B-Tree索引的查询类型
1.  全值匹配
2.  匹配最左前缀
3.  匹配列前缀
4.  匹配范围值
5.  精确匹配某一列并范围匹配另外一列
6.  只访问索引的查询

**Tip：如果不是按照索引的最左列开始查找，则无法使用索引。**
**不能跳过索引中的列。**
**如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。**

#### 5.1.1.2. 哈希索引
1.  哈希索引只包含哈希值和行指针，而不存储字段值。
2.  哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序
3.  哈希索引也不支持部分索引列匹配查找。
4.  哈希索引只支持等值比较查询。
5.  哈希冲突，遍历链表。

InnoDB存储引擎有一个特殊的功能：自适应哈希索引(adaptive hash index),当某些索引值用的非常频繁时，在内存中基于B-Tree索引之上再创建一个Hash索引。

不要使用SHA1()和MD5()作为哈希函数（太长，浪费空间），这两个是强加密函数，设计目标是最大限度消除冲突。

使用MD5()返回值的一部分来作为自定义哈希函数。

#### 5.1.1.3. 空间数据索引
#### 5.1.1.4. 全文索引
全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。
## 5.2. 索引的优点
因为索引中存储了实际的列值，所以某些操作只使用索引就能完成全部的查询。

1.  索引大大减少了服务器需要扫描的数据量。
2.  索引可以帮助服务器避免排序和临时表。
3.  索引可以将随机I/O变为顺序I/O。

TB级别用块级别元数据急速代替索引。
## 5.3. 高性能的索引策略
### 5.3.1. 独立的列
如果查询中的列不是独立的，那么MySQL就不会使用索引。
### 5.3.2. 前缀索引和索引选择性
通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。

对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不准索引这些列的完整长度。

决定前缀的合适长度
1.  找到常见的值的列表，然后和最常见的前缀列表比较。
2.  计算完整列的选择性，并使前缀列的选择性接近完整列的选择性。

### 5.3.3. 多列索引
### 5.3.4. 选择合适的索引列排序
### 5.3.5. 聚簇索引
聚簇索引并不是一种单独的索引类型，而是一种存储方式。
因为是存储引擎负责索引，所以不是所有的存储引擎都是聚簇索引。
InnoDB只聚集在同一个页面中的记录，所以包含相邻键值的页面可能会相距甚远。
基于聚簇索引的表在插入新行，或者在主键被更新需要移动行的时候，可能面临页分裂（'page split'）的问题，页分裂会导致表占用更多的磁盘空间。
#### 5.3.5.1. ）InnoDB和MyISAM的数据分布对比
##### 5.3.5.1.1. MyISAM的数据分布
按照数据插入顺序存储在磁盘上。
##### 5.3.5.1.2. InnoDB的数据分布
聚簇索引就是表。
InnoDB二级索引存储主键值的好处？减少出现行移动或者数据页分列时二级索引的维护工作。
B-Tree的非叶子节点包含了索引列和指向下一级节点的指针。
#### 5.3.5.2. ) 在InnoDB中按主键顺序插入行
如果正在使用InnoDB表并且没有数据需要聚集，可以定义一个代理键（surrogate key）作为主键。
example：AUTO_INCREMENT自增列

WARN:必须保证能够顺序写入。（不要使用UUID，会导致页分裂和碎片）

页的最大填充因子（InnoDB默认为15/16，留出部分空间用于以后的修改）

问题：OPTIMIZE TABLE的作用？
问题：顺序的主键什么时候会造成更坏的效果？
### 5.3.6. 覆盖索引
原理：MySQL可以使用索引直接获取列的数据，不需要再读取数据行。如果索引的叶子节点已经包含要查询的数据，那么就是覆盖索引。

InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级节点能够覆盖查询，则可以避免对主键索引的二次查询。

覆盖索引必须要存储索引列的值，MySQL只能使用B-Tree索引做覆盖索引。（哈希索引、空间索引和全文索引都不支持存储索引列的值）。
不同存储引擎实现覆盖索引的方式不同，而且不是所有引擎搜支持覆盖索引。

通过EXPLAIN测试，其中Extra表明使用了覆盖索引。
##### 5.3.6.0.1. type列和Extra列的区别：type列表示查询访问数据的方式（join type），Extra列表示是否使用覆盖索引。
```
mysql> EXPLAIN SELECT store_id, film_id FROM sakila.inventory\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: inventory
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_store_id_film_id
      key_len: 3
          ref: NULL
         rows: 4581
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)

ERROR:
No query specified
```
MySQL只能在索引中执行最左前缀匹配的LIKE比较查询，不能执行通配符开头的LIKE查询。

##### 5.3.6.0.2. 延迟关联（deferred join）
原理：在查询的第一阶段（子查询）覆盖索引。
索引：products(artist,title,prod_id)
```
SELECT *
FROM products
  JOIN (
    SELECT prod_id
    FROM products
    WHERE actor='SEAN CARREY' AND title LIKE ‘%APOLLO%’
  ) AS t1 ON (t1.prod_id=products.prod_id) ;
```
Tip：外查询可以利用其它索引。（已知prod_id）

问题： 索引条件推送（index condition pushdown）（可以非显式使用延迟关联）
### 5.3.7. 使用索引扫描来做排序
背景：MySQL有两种方式可以生成有序的结果：通过排序操作；按索引顺序扫描。

1、如果索引不能覆盖所查找的全部的列，那么每扫描到一条索引记录都会回表查询一次对应的行（基本上是随机I/O）。
2、只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。
3、如果查询关联多张表，那么只有当ORDER BY子句引用的字段全部为第一张表时，才能用索引做排序。
4、索引中的列要满足最左前缀要求。（例外：前导列为常量）
### 5.3.8. 压缩（前缀压缩）索引（MyISAM）
#### 5.3.8.1. 背景
MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引放入内存中。某些情况下可以极大地提高性能。默认只压缩字符串，但是通过参数设置也可以对整数做压缩。
#### 5.3.8.2. 方法
保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，保存这些数据。
example： perform（perform） performance（7,ance）
MyISAM对行指针也采用类似的前缀压缩方式。
#### 5.3.8.3. 缺点
无法进行二分查找，只能从头开始扫描。
倒序扫描速度慢，在块中查找某一行平均要扫描半个块。
#### 5.3.8.4. 结论
适用于I/O密集型应用，不适用于CPU密集型应用。
### 5.3.9. 冗余和重复索引
背景：MySQl允许在相同列上创建多个索引。

重复索引是在相同列上按照相同的顺序创建的相同类型的索引。（发现后应立即移除）
### 5.3.10. 未使用的索引
1.  永远不用的索引考虑删除。
2.  在Percona Server或者MariaDB中打开userstates服务器变量，再通过查询INFORMATION_SCHEMA.INDEX_STATISTICS查询每个索引的使用频率。

### 5.3.11. 索引和锁
## 5.4. 索引案例学习
### 5.4.1. 支持多种过滤条件
### 5.4.2. 避免多个范围条件
### 5.4.3. 优化排序
## 5.5. 维护索引和表
### 5.5.1. 找到并修复损坏的表
### 5.5.2. 更新索引统计信息
### 5.5.3. 减少索引和数据的碎片
## 5.6. 总结
# 6. 查询性能优化
优化的方面：查询优化、索引优化、库表结构优化
## 6.1. 为什么查询速度会慢
快速的查询真正重要的是**响应时间**。

查询的生命周期
1. 客户端
2. 服务器
3. 在服务器上解析
4. 生成执行计划
5. 执行（最重要的阶段）
6. 返回结果给客户端

## 6.2. 慢查询基础：优化数据访问
查询性能低下最基本的原因是访问的数据太多
优化方式：减少访问的数据量

分析步骤：
1. 确认应用是否在检索大量超过需要的数据。
2. 确认MySQl服务器层是否在分析大量超过需要的数据行。

### 6.2.1. 是否向数据库请求了不需要的列
有些查询会请求超过实际需要的数据，然后多余的数据会被应用程序丢弃。
1. 查询不需要的记录。（在这样的查询后面加上LIMIT）
2. 多表关联时返回全部列。
3. 总是取出全部列。
4. 重复查询相同的数据。（应使用缓存技术）

### 6.2.2. MySQL是否在扫描额外的记录
衡量开销的指标
-   响应时间
-   扫描的行数
-   返回的行数

这三个指标全部记录在慢查询日志中。
检查慢查询日志是找出扫描行数过多的查询的好办法。
#### 6.2.2.1. 响应时间
响应时间分为：服务时间和排队时间
影响响应时间的因素：存储引擎的锁（表锁、行锁）、高并发资源竞争、硬件响应等。

判断响应时间是否合理？
了解这个查询需要哪些索引以及执行计划，计算大概需要多少个顺序和随机I/O，乘以在具体硬件下I/O的消耗时间，最后加起来，得到参考值。
#### 6.2.2.2. 扫描的行数和返回的行数
扫描的行数
1. 分析查询时，查询扫描的行数可以说明该查询找到需要的数据的效率高不高。
2. 但是不是所有的行访问的代价都是相同的。

返回的行数
1. 扫描的行数对返回的行数的比例一般在1:1和10:1之间。（MySQL不会显示生成结果实际上需要扫描多少行数据，只会显示生成结果时一共扫描了多少行数据）
#### 6.2.2.3. 扫描的行数和访问类型
1.  在评估查询开销时，需要考虑从表中找到某一行的成本。
2.  EXPLAIN语句中的type列反映了访问类型？
全表扫描、索引扫描、范围扫描、唯一索引查询、常数引用等（速度从快到慢）。
3.  如果查询不能找到合适的访问类型，通常应增加一个合适的索引。

#### 6.2.2.4. 应用where条件的方式
1.  在索引中使用WHERE条件来过滤不匹配的记录。（在存储引擎层完成）
2.  使用索引覆盖扫描（在EXTRA列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。（这是在MySQl服务器中完成的，但无须再回表查询）
3.  从数据表中返回数据，然后过滤不满足的条件（在Extra列中出现Using where）。（在MySQl服务器中完成，需要先从数据表中读出记录然后过滤）

**并不是说增加索引就能让扫描的行数等于返回的行数**

#### 6.2.2.5. 扫描大量数据只返回少数的行的解决方法
1.  使用覆盖索引扫描，把所有需要的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果。
2.  改变库表结构。（例如使用单独的汇总表）
3.  重写这个复杂的查询。

## 6.3. 重构查询的方式
### 6.3.1. 一个复杂的查询还是多个简单的查询
是否需要将一个复杂的查询分成多个简单的查询。
原因：MySQl从设计上让链接和断开都很轻量级，在返回一个小的查询结果方面很高效。

如果一个查询能够胜任时还写成多个独立查询是不明智的。
### 6.3.2. 切分查询
1.  原理：“分而治之”，将大查询切分成小查询。
2.  例子：定期清除大量数据时，如果用一个大的语句一次性完成，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但是重要的查询。
3.  如果是事务型引擎，很多时候小事务能够更高效。

### 6.3.3. 分解关联查询
很多高性能的应用都会对关联查询进行分解，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。

分解关联查询的优势？
1. 让缓存的效率更高。
2. 将查询分解后，执行单个查询可以减少锁的竞争。
3. 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
4. 查询效率本身也会提升。（取出数据后再使用IN()操作比关联查询中的随机查询效率更高）
5. 减少冗余记录的查询。
6. 相当于在应用中实现了哈希关联，而不是用MySQL的嵌套循环关联。

关联查询的使用场景？
1. 当应用能够方便地缓存单个查询的结果的时候。
2. 当可以将数据拆分到不同的MySQL服务器上的时候。
3. 当能够使用IN()的方式代替关联查询的时候。
4. 当查询中使用同一个数据表的时候。

## 6.4. 执行查询的基础
### 6.4.1. MySQl客户端/服务器通信协议
MySQL客户端和服务器之间的通信协议是“半双工”的。（不能进行流量控制）

接受全部结果并缓存通常可以减少服务器压力，让查询能够早点结束、早点释放相应的资源。

#### 6.4.1.1. 查询状态
`SHOW FULL PROCESSLIST ;`
1. Sleep
2. Query
3. Locked
4. Analyzing and statistics
5. Copy to tmp table \[on disk]
6. Sorting result
7. Sending data

### 6.4.2. 查询缓存
在解析查询语句之前，如果查询缓存是打开的，优先查找缓存（通过大小写敏感的哈希查找实现），如果命中，检查用户权限（通过查询缓存中当前查询需要访问的表信息查看）
### 6.4.3. 查询优化处理
将SQL转换成一个执行计划。
过程：解析SQL、预处理、优化SQL执行计划。
能够优化的类型？
1. 重新定义关联表顺序。
2. 将外连接转化为内连接。
3. 使用等价变化规则。
4. 优化COUNT()、MIN()、MAX()
5. 预估并转化为常数表达式。
6. 覆盖索引扫描。
7. 子查询优化。
8. 提前终止查询。
9. 等值传播。
10. 列表IN()的比较。

### 6.4.4. 查询执行引擎
### 6.4.5. 返回结果给客户端
## 6.5. MySQL查询优化器的局限性
### 6.5.1. 关联子查询
### 6.5.2. UNION的限制
### 6.5.3. 索引合并优化
### 6.5.4. 等值传递
### 6.5.5. 并行执行
### 6.5.6. 哈希关联
### 6.5.7. 松散索引扫描
### 6.5.8. 最大值和最小值优化
### 6.5.9. 在同一个表上查询和更新
## 6.6. 查询优化器的提示（hint）
## 6.7. 优化特定类型的查询
### 6.7.1. 优化COUNT()查询
### 6.7.2. 优化关联查询
### 6.7.3. 优化子查询
### 6.7.4. 优化GROUP BY和DESTINCT
### 6.7.5. 优化LIMIT分页
### 6.7.6. 优化SQL_CALC_FOUND_ROWS
### 6.7.7. 优化UNION查询
### 6.7.8. 静态查询分析
### 6.7.9. 使用用户自定义变量
## 6.8. 案例学习
### 6.8.1. 使用MySQL构建一个队列表
### 6.8.2. 计算两点之间的距离
### 6.8.3. 使用用户自定义函数
## 6.9. 总结
# 7. MySQL高级特性
## 7.1. 分区表
1.  分区表底层由多个物理子表组成。
2.  实现分区的代码是对一组底层表的句柄对象(Handler Object)的封装。
3.  索引是按照分区的字表定义的，**没有全局索引**。
4.  目的：将数据按照一个较粗的粒度分在不同的表中。

## 7.2. 视图
1.  试图本身是一个虚拟表，不存放任何数据。
2.  不能对试图创建触发器。
3.  实现方法：合并算法和临时表算法。
### 7.2.1. 可更新视图
### 7.2.2. 视图对性能的影响
### 7.2.3. 视图的限制
1.  MySQL不支持物化视图，也不支持在视图中创建索引。
2.  MySQL不会保存视图定义的原始语句。

## 7.3. 外键约束
1.  InnoDB是MySQL中唯一支持外键的内置存储引擎。
2.  MySQL强制外键使用索引。
3.  修改数据要进行额外的约束性检查。
4.  导致额外的锁等待。
 
## 7.4. 在MySQL内部存储代码
存储过程和存储函数统称为“存储程序”。
### 7.4.1. 存储过程和函数
### 7.4.2. 触发器
1.  使用触发器实现强制限制。
2.  对于每个表的每一个事件，最多定义一个触发器。
3.  只支持基于行的触发。

### 7.4.3. 事件
指定MySQL某个时候执行一段SQL代码，或者每隔一个时间间隔执行一段SQL代码。
### 7.4.4. 在存储过程中保留注释
使用版本相关的注释（只有版本号大于某个值才执行的代码）
## 7.5. 游标
1.  MySQL在服务器端只提供只读的、单向的游标，而且只在存储过程或者更底层的客户端API中使用。
2.  需要使用limit来限制返回集。
## 7.6. 绑定变量
`INSERT INTO tb1(col1, col2, col3) VALUES (?, ?, ?);`
### 7.6.1. 绑定变量的优化
### 7.6.2. SQL接口的绑定变量
### 7.6.3. 绑定变量的限制

## 7.7. 用户自定义函数
可以使用支持C语言调用约定的任何编程语言来实现。
## 7.8. 插件
1.  存储过程插件
2.  后台查件
3.  INFORMATION_SCHEMA插件
4.  全文解析插件
5.  审计插件
6.  认证插件

## 7.9. 字符集和校对
### 7.9.1. MySQL如何使用字符集
### 7.9.2. 选择字符集和校对规则
### 7.9.3. 字符集和校对规则如何影响查询

## 7.10. 全文索引
1.  目的：基于相似度的查询。
2.  没有索引也可以工作，有索引效率会更高。
3.  

## 7.11. 分布式（XA）事务
## 7.12. 查询缓存
## 7.13. 总结 
# 8. 优化服务器设置
## 8.1. MySQL配置的工作原理
1.  MySQL从命令行参数和配置文件获得配置信息。
2.  在类UNIX系统中，配置文件的位置一般在/etc/my.cnf或者/etc/mysql/my.cnf。
## 8.2. 什么不该做
1.  没有一个适合所有场景的“最佳配置文件”。

## 8.3. 创建MySQL配置文件
### 8.3.1. 检查MySQL服务器状态变量
1.  使用`mysqladmin extended-status -ri60`每隔60s查看状态变量的增量变化。
## 8.4. 配置内存使用
1.  确认可以使用的内存上限。
2.  确认每个连接MySQL需要使用多少内存，例如排序缓冲和临时表。
3.  确认操作系统需要多少内存才够用。包括同一台机器上其他程序使用的内存，如定时任务。
4.  把省下的内存全部给MySQL的缓存，例如InnoDB的缓冲池，这样做很有意义。
### 8.4.1. MySQL可以使用多少内存
### 8.4.2. 每个连接需要的内存
### 8.4.3. 为操作系统保留内存
### 8.4.4. 为缓存分配内存
### 8.4.5. InnoDB缓冲池（Buffer Pool）
### 8.4.6. MyISAM键缓存（Key Caches）
### 8.4.7. 线程缓存
### 8.4.8. 表缓存（Table Cache）
### 8.4.9. InnoDB数据字典（Data Dictionary）

## 8.5. 配置MySQL的I/O行为
### 8.5.1. InnoDB I/O配置
### 8.5.2. MyISAM的I/O配置

## 8.6. 配置MySQL并发
### 8.6.1. InnoDB的并发配置
### 8.6.2. MyISAM并发配置

## 8.7. 基于工作负载的配置
### 8.7.1. 优化BLOB和TEXT的场景
### 8.7.2. 优化排序（Filesorts）

## 8.8. 完成基本配置
## 8.9. 安全和稳定的配置
## 8.10. 高级InnoDB设置
## 8.11. 总结
# 9. 操作系统和硬件优化
## 9.1. 什么限制了MySQL的性能
## 9.2. 如何为MySQL选择CPU
## 9.3. 平衡内存和磁盘资源
## 9.4. 固态存储
## 9.5. 为备库选择硬件
## 9.6. RAID性能优化
## 9.7. SAN和NAS
## 9.8. 使用多磁盘卷
## 9.9. 网络配置
## 9.10. 选择操作系统
## 9.11. 选择文件系统
## 9.12. 选择磁盘队列调度策略
## 9.13. 线程
## 9.14. 内存交换区
## 9.15. 操作系统状态
## 9.16. 总结
# 10. 复制
## 10.1. 复制概述
## 10.2. 配置复制
## 10.3. 复制的原理
## 10.4. 复制拓扑
## 10.5. 复制和容量规划
## 10.6. 复制管理和维护
## 10.7. 复制的问题和解决方案
## 10.8. 复制有多快
## 10.9. MySQL复制的高级特性
## 10.10. 其他复制技术
## 10.11. 总结
# 11. 可扩展的MySQL
## 11.1. 什么是可扩展性
## 11.2. 扩展MySQL
## 11.3. 负载均衡
## 11.4. 总结
# 12. 高可用性
## 12.1. 什么是高可用性
## 12.2. 导致宕机的原因
## 12.3. 如何实现高可用性
## 12.4. 避免单点失效
## 12.5. 故障转移和故障恢复
## 12.6. 总结
# 13. 云端的MySQL
## 13.1. 云的优点、缺点和相关误解
## 13.2. MySQL 在云端的经济价值
## 13.3. 云中的MySQL 的可扩展性和高可用性
## 13.4. 四种基础资源
## 13.5. MySQL 在云主机上的性能
## 13.6. MySQL 数据库即服务（DBaaS）
## 13.7. 总结
# 14. 应用层优化
## 14.1. 常见问题
## 14.2. Web 服务器问题
## 14.3. 缓存
## 14.4. 拓展MySQL
## 14.5. MySQL的替代产品
## 14.6. 总结
# 15. 备份和恢复
## 15.1. 为什么要备份
## 15.2. 定义恢复需求
## 15.3. 设计MySQL备份方案
## 15.4. 管理和备份二进制日志
## 15.5. 备份数据
## 15.6. 从备份中恢复
## 15.7. 备份和恢复工具
## 15.8. 备份脚本化
## 15.9. 总结
# 16. MySQL用户工具
## 16.1. 接口工具
## 16.2. 命令行工具集
## 16.3. SQL实用集
## 16.4. 监测工具
## 16.5. 总结