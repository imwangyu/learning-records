# 第一章 MySQL架构与历史
## 1.1 MySQL逻辑架构
## 1.2 并发控制
## 1.3 事务
## 1.4 多版本并发控制
## 1.5 MySQl的存储引擎
## 1.6 MySQl时间线（Timeline）
## 1.7 MySQL的开发模式
## 1.8 总结
# 第二章 MySQL基准测试
# 第三章 服务器性能剖析
# 第四章 Schema与数据类型优化
## 4.1 选择优化的数据类型
## 4.2 MySQl schema设计中的陷阱
## 4.3 范式和反范式
## 4.4 缓存表和汇总表
## 4.5 加快ALTER TABLE操作的速度
## 4.6 总结
# 第五章 创建高性能索引
##### 背景：不恰当使用索引，当数据量逐渐增大时，性能会急剧下降。
## 5.1 索引基础
如果索引包含多个列，那么列的顺序也十分重要，因为MySql只能高效地使用索引的最左前缀列。
##### Tip：关于ORM框架：除非只是生成非常基本的查询（例如仅是根据主键查询），否则很难生成适合索引的查询。
### 索引的类型
在MySQL中，索引是在引擎层而不是在服务器层实现的。（并不是所有的引擎都支持索引）
##### Tip：很多存储引擎都是用的B+Tree，即每一个叶子节点都包含指向下一个叶子节点的指针。
MyISAM索引通过数据的物理位置引用被索引的行；InnoDB则根据主键引用被索引的行（所以二级索引需要两次索引查找）。
#### 可以使用B-Tree索引的查询类型
全值匹配
匹配最左前缀
匹配列前缀
匹配范围值
精确匹配某一列并范围匹配另外一列
只访问索引的查询
##### Tip：如果不是按照索引的最左列开始查找，则无法使用索引。
##### 不能跳过索引中的列。
##### 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。
## 5.2 索引的优点

## 5.3 高性能的索引策略
### 5.3.1 独立的列
### 5.3.2 前缀索引和索引选择性
### 5.3.3 多列索引
### 5.3.4 选择合适的索引列排序
### 5.3.5 聚簇索引
聚簇索引并不是一种单独的索引类型，而是一种存储方式。
因为是存储引擎负责索引，所以不是所有的存储引擎都是聚簇索引。
InnoDB只聚集在同一个页面中的记录，所以包含相邻键值的页面可能会相距甚远。
基于聚簇索引的表在插入新行，或者在主键被更新需要移动行的时候，可能面临页分裂（'page split'）的问题，页分裂会导致表占用更多的磁盘空间。
#### 1）InnoDB和MyISAM的数据分布对比
##### MyISAM的数据分布
按照数据插入顺序存储在磁盘上。
##### InnoDB的数据分布
聚簇索引就是表。
InnoDB二级索引存储主键值的好处？减少出现行移动或者数据页分列时二级索引的维护工作。
B-Tree的非叶子节点包含了索引列和指向下一级节点的指针。
#### 2) 在InnoDB中按主键顺序插入行
如果正在使用InnoDB表并且没有数据需要聚集，可以定义一个代理键（surrogate key）作为主键。
example：AUTO_INCREMENT自增列

WARN:必须保证能够顺序写入。（不要使用UUID，会导致页分裂和碎片）

页的最大填充因子（InnoDB默认为15/16，留出部分空间用于以后的修改）

问题：OPTIMIZE TABLE的作用？
问题：顺序的主键什么时候会造成更坏的效果？
### 5.3.6 覆盖索引
原理：MySQL可以使用索引直接获取列的数据，不需要再读取数据行。如果索引的叶子节点已经包含要查询的数据，那么就是覆盖索引。

InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级节点能够覆盖查询，则可以避免对主键索引的二次查询。

覆盖索引必须要存储索引列的值，MySQL只能使用B-Tree索引做覆盖索引。（哈希索引、空间索引和全文索引都不支持存储索引列的值）。
不同存储引擎实现覆盖索引的方式不同，而且不是所有引擎搜支持覆盖索引。

通过EXPLAIN测试，其中Extra表明使用了覆盖索引。
##### type列和Extra列的区别：type列表示查询访问数据的方式（join type），Extra列表示是否使用覆盖索引。
```
mysql> EXPLAIN SELECT store_id, film_id FROM sakila.inventory\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: inventory
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_store_id_film_id
      key_len: 3
          ref: NULL
         rows: 4581
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)

ERROR:
No query specified
```
MySQL只能在索引中执行最左前缀匹配的LIKE比较查询，不能执行通配符开头的LIKE查询。

##### 延迟关联（deferred join）
原理：在查询的第一阶段（子查询）覆盖索引。
索引：products(artist,title,prod_id)
```
SELECT *
FROM products
  JOIN (
    SELECT prod_id
    FROM products
    WHERE actor='SEAN CARREY' AND title LIKE ‘%APOLLO%’
  ) AS t1 ON (t1.prod_id=products.prod_id) ;
```
Tip：外查询可以利用其它索引。（已知prod_id）

问题： 索引条件推送（index condition pushdown）（可以非显式使用延迟关联）
### 5.3.7 使用索引扫描来做排序
背景：MySQL有两种方式可以生成有序的结果：通过排序操作；按索引顺序扫描。

1、如果索引不能覆盖所查找的全部的列，那么每扫描到一条索引记录都会回表查询一次对应的行（基本上是随机I/O）。
2、只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。
3、如果查询关联多张表，那么只有当ORDER BY子句引用的字段全部为第一张表时，才能用索引做排序。
4、索引中的列要满足最左前缀要求。（例外：前导列为常量）
### 5.3.8 压缩（前缀压缩）索引（MyISAM）
#### 背景
MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引放入内存中。某些情况下可以极大地提高性能。默认只压缩字符串，但是通过参数设置也可以对整数做压缩。
#### 方法
保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，保存这些数据。
example： perform（perform） performance（7,ance）
MyISAM对行指针也采用类似的前缀压缩方式。
#### 缺点
无法进行二分查找，只能从头开始扫描。
倒序扫描速度慢，在块中查找某一行平均要扫描半个块。
#### 结论
适用于I/O密集型应用，不适用于CPU密集型应用。
### 5.3.9 冗余和重复索引
背景：MySQl允许在相同列上创建多个索引。

重复索引是在相同列上按照相同的顺序创建的相同类型的索引。（发现后应立即移除）
### 5.3.10 未使用的索引
### 5.3.11 索引和锁
## 5.4 索引案例学习
### 5.4.1 支持多种过滤条件
### 5.4.2 避免多个范围条件
### 5.4.3 优化排序
## 5.5 维护索引和表
### 5.5.1 找到并修复损坏的表
### 5.5.2 更新索引统计信息
### 5.5.3 减少索引和数据的碎片
## 5.6 总结
# 第六章 查询性能优化
## 6.1 为什么查询速度会慢
