# 第一章 MySQL架构与历史
## 1.1 MySQL逻辑架构
## 1.2 并发控制
## 1.3 事务
## 1.4 多版本并发控制
## 1.5 MySQl的存储引擎
## 1.6 MySQl时间线（Timeline）
## 1.7 MySQL的开发模式
## 1.8 总结
# 第二章 MySQL基准测试
# 第三章 服务器性能剖析
# 第四章 Schema与数据类型优化
## 4.1 选择优化的数据类型
## 4.2 MySQl schema设计中的陷阱
## 4.3 范式和反范式
## 4.4 缓存表和汇总表
## 4.5 加快ALTER TABLE操作的速度
## 4.6 总结
# 第五章 创建高性能索引
##### 背景：不恰当使用索引，当数据量逐渐增大时，性能会急剧下降。
## 5.1 索引基础
如果索引包含多个列，那么列的顺序也十分重要，因为MySql只能高效地使用索引的最左前缀列。
**Tip：关于ORM框架：除非只是生成非常基本的查询（例如仅是根据主键查询），否则很难生成适合索引的查询。**
### 索引的类型
在MySQL中，索引是在引擎层而不是在服务器层实现的。（并不是所有的引擎都支持索引）
**Tip：很多存储引擎都是用的B+Tree，即每一个叶子节点都包含指向下一个叶子节点的指针。**
MyISAM索引通过数据的物理位置引用被索引的行；InnoDB则根据主键引用被索引的行（所以二级索引需要两次索引查找）。
#### 可以使用B-Tree索引的查询类型
1. 全值匹配
2. 匹配最左前缀
3. 匹配列前缀
4. 匹配范围值
5. 精确匹配某一列并范围匹配另外一列
6. 只访问索引的查询

**Tip：如果不是按照索引的最左列开始查找，则无法使用索引。**
##### 不能跳过索引中的列。
##### 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。
## 5.2 索引的优点

## 5.3 高性能的索引策略
### 5.3.1 独立的列
### 5.3.2 前缀索引和索引选择性
### 5.3.3 多列索引
### 5.3.4 选择合适的索引列排序
### 5.3.5 聚簇索引
聚簇索引并不是一种单独的索引类型，而是一种存储方式。
因为是存储引擎负责索引，所以不是所有的存储引擎都是聚簇索引。
InnoDB只聚集在同一个页面中的记录，所以包含相邻键值的页面可能会相距甚远。
基于聚簇索引的表在插入新行，或者在主键被更新需要移动行的时候，可能面临页分裂（'page split'）的问题，页分裂会导致表占用更多的磁盘空间。
#### 1）InnoDB和MyISAM的数据分布对比
##### MyISAM的数据分布
按照数据插入顺序存储在磁盘上。
##### InnoDB的数据分布
聚簇索引就是表。
InnoDB二级索引存储主键值的好处？减少出现行移动或者数据页分列时二级索引的维护工作。
B-Tree的非叶子节点包含了索引列和指向下一级节点的指针。
#### 2) 在InnoDB中按主键顺序插入行
如果正在使用InnoDB表并且没有数据需要聚集，可以定义一个代理键（surrogate key）作为主键。
example：AUTO_INCREMENT自增列

WARN:必须保证能够顺序写入。（不要使用UUID，会导致页分裂和碎片）

页的最大填充因子（InnoDB默认为15/16，留出部分空间用于以后的修改）

问题：OPTIMIZE TABLE的作用？
问题：顺序的主键什么时候会造成更坏的效果？
### 5.3.6 覆盖索引
原理：MySQL可以使用索引直接获取列的数据，不需要再读取数据行。如果索引的叶子节点已经包含要查询的数据，那么就是覆盖索引。

InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级节点能够覆盖查询，则可以避免对主键索引的二次查询。

覆盖索引必须要存储索引列的值，MySQL只能使用B-Tree索引做覆盖索引。（哈希索引、空间索引和全文索引都不支持存储索引列的值）。
不同存储引擎实现覆盖索引的方式不同，而且不是所有引擎搜支持覆盖索引。

通过EXPLAIN测试，其中Extra表明使用了覆盖索引。
##### type列和Extra列的区别：type列表示查询访问数据的方式（join type），Extra列表示是否使用覆盖索引。
```
mysql> EXPLAIN SELECT store_id, film_id FROM sakila.inventory\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: inventory
   partitions: NULL
         type: index
possible_keys: NULL
          key: idx_store_id_film_id
      key_len: 3
          ref: NULL
         rows: 4581
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)

ERROR:
No query specified
```
MySQL只能在索引中执行最左前缀匹配的LIKE比较查询，不能执行通配符开头的LIKE查询。

##### 延迟关联（deferred join）
原理：在查询的第一阶段（子查询）覆盖索引。
索引：products(artist,title,prod_id)
```
SELECT *
FROM products
  JOIN (
    SELECT prod_id
    FROM products
    WHERE actor='SEAN CARREY' AND title LIKE ‘%APOLLO%’
  ) AS t1 ON (t1.prod_id=products.prod_id) ;
```
Tip：外查询可以利用其它索引。（已知prod_id）

问题： 索引条件推送（index condition pushdown）（可以非显式使用延迟关联）
### 5.3.7 使用索引扫描来做排序
背景：MySQL有两种方式可以生成有序的结果：通过排序操作；按索引顺序扫描。

1、如果索引不能覆盖所查找的全部的列，那么每扫描到一条索引记录都会回表查询一次对应的行（基本上是随机I/O）。
2、只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。
3、如果查询关联多张表，那么只有当ORDER BY子句引用的字段全部为第一张表时，才能用索引做排序。
4、索引中的列要满足最左前缀要求。（例外：前导列为常量）
### 5.3.8 压缩（前缀压缩）索引（MyISAM）
#### 背景
MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引放入内存中。某些情况下可以极大地提高性能。默认只压缩字符串，但是通过参数设置也可以对整数做压缩。
#### 方法
保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，保存这些数据。
example： perform（perform） performance（7,ance）
MyISAM对行指针也采用类似的前缀压缩方式。
#### 缺点
无法进行二分查找，只能从头开始扫描。
倒序扫描速度慢，在块中查找某一行平均要扫描半个块。
#### 结论
适用于I/O密集型应用，不适用于CPU密集型应用。
### 5.3.9 冗余和重复索引
背景：MySQl允许在相同列上创建多个索引。

重复索引是在相同列上按照相同的顺序创建的相同类型的索引。（发现后应立即移除）
### 5.3.10 未使用的索引
### 5.3.11 索引和锁
## 5.4 索引案例学习
### 5.4.1 支持多种过滤条件
### 5.4.2 避免多个范围条件
### 5.4.3 优化排序
## 5.5 维护索引和表
### 5.5.1 找到并修复损坏的表
### 5.5.2 更新索引统计信息
### 5.5.3 减少索引和数据的碎片
## 5.6 总结
# 第六章 查询性能优化
优化的方面：查询优化、索引优化、库表结构优化
## 6.1 为什么查询速度会慢
快速的查询真正重要的是**响应时间**。

查询的生命周期
1. 客户端
2. 服务器
3. 在服务器上解析
4. 生成执行计划
5. 执行（最重要的阶段）
6. 返回结果给客户端
## 6.2 慢查询基础：优化数据访问
查询性能低下最基本的原因是访问的数据太多
优化方式：减少访问的数据量

分析步骤：
1. 确认应用是否在检索大量超过需要的数据。
2. 确认MySQl服务器层是否在分析大量超过需要的数据行。
### 6.2.1 是否向数据库请求了不需要的列
有些查询会请求超过实际需要的数据，然后多余的数据会被应用程序丢弃。
1. 查询不需要的记录。（在这样的查询后面加上LIMIT）
2. 多表关联时返回全部列。
3. 总是取出全部列。
4. 重复查询相同的数据。（应使用缓存技术）
### 6.2.2 MySQL是否在扫描额外的记录
衡量开销的指标
- 响应时间
- 扫描的行数
- 返回的行数

这三个指标全部记录在慢查询日志中。
检查慢查询日志是找出扫描行数过多的查询的好办法。
#### 响应时间
响应时间分为：服务时间和排队时间
影响响应时间的因素：存储引擎的锁（表锁、行锁）、高并发资源竞争、硬件响应等。

判断响应时间是否合理？
了解这个查询需要哪些索引以及执行计划，计算大概需要多少个顺序和随机I/O，乘以在具体硬件下I/O的消耗时间，最后加起来，得到参考值。
#### 扫描的行数和返回的行数
扫描的行数
1. 分析查询时，查询扫描的行数可以说明该查询找到需要的数据的效率高不高。
2. 但是不是所有的行访问的代价都是相同的。

返回的行数
1. 扫描的行数对返回的行数的比例一般在1:1和10:1之间。（MySQL不会显示生成结果实际上需要扫描多少行数据，只会显示生成结果时一共扫描了多少行数据）
#### 扫描的行数和访问类型
1. 在评估查询开销时，需要考虑从表中找到某一行的成本。
2. EXPLAIN语句中的type列反映了访问类型？
全表扫描、索引扫描、范围扫描、唯一索引查询、常数引用等（速度从快到慢）。
3. 如果查询不能找到合适的访问类型，通常应增加一个合适的索引。
### 应用where条件的方式
1. 在索引中使用WHERE条件来过滤不匹配的记录。（在存储引擎层完成）
2. 使用索引覆盖扫描（在EXTRA列中出现了Using index）来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。（这是在MySQl服务器中完成的，但无须再回表查询）
3. 从数据表中返回数据，然后过滤不满足的条件（在Extra列中出现Using where）。（在MySQl服务器中完成，需要先从数据表中读出记录然后过滤）

**并不是说增加索引就能让扫描的行数等于返回的行数**

#### 扫描大量数据只返回少数的行的解决方法
1. 使用覆盖索引扫描，把所有需要的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果。
2. 改变库表结构。（例如使用单独的汇总表）
3. 重写这个复杂的查询。
## 6.3 重构查询的方式
### 6.3.1 一个复杂的查询还是多个简单的查询
是否需要将一个复杂的查询分成多个简单的查询。
原因：MySQl从设计上让链接和断开都很轻量级，在返回一个小的查询结果方面很高效。

如果一个查询能够胜任时还写成多个独立查询是不明智的。
### 6.3.2 切分查询
1. 原理：“分而治之”，将大查询切分成小查询。
2. 例子：定期清除大量数据时，如果用一个大的语句一次性完成，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但是重要的查询。
3. 如果是事务型引擎，很多时候小事务能够更高效。
### 6.3.3 分解关联查询
很多高性能的应用都会对关联查询进行分解，可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。

分解关联查询的优势？
1. 让缓存的效率更高。
2. 将查询分解后，执行单个查询可以减少锁的竞争。
3. 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
4. 查询效率本身也会提升。（取出数据后再使用IN()操作比关联查询中的随机查询效率更高）
5. 减少冗余记录的查询。
6. 相当于在应用中实现了哈希关联，而不是用MySQL的嵌套循环关联。

关联查询的使用场景？
1. 当应用能够方便地缓存单个查询的结果的时候。
2. 当可以将数据拆分到不同的MySQL服务器上的时候。
3. 当能够使用IN()的方式代替关联查询的时候。
4. 当查询中使用同一个数据表的时候。
## 6.4 执行查询的基础
### 6.4.1 MySQl客户端/服务器通信协议
MySQL客户端和服务器之间的通信协议是“半双工”的。（不能进行流量控制）

接受全部结果并缓存通常可以减少服务器压力，让查询能够早点结束、早点释放相应的资源。

####查询状态
> SHOW FULL PROCESSLIST ;
1. Sleep
2. Query
3. Locked
4. Analyzing and statistics
5. Copy to tmp table [on disk]
6. Sorting result
7. Sending data
### 6.4.2 查询缓存
在解析查询语句之前，如果查询缓存是打开的，优先查找缓存（通过大小写敏感的哈希查找实现），如果命中，检查用户权限（通过查询缓存中当前查询需要访问的表信息查看）
### 6.4.3 查询优化处理
将SQL转换成一个执行计划。
过程：解析SQL、预处理、优化SQL执行计划。
能够优化的类型？
1. 重新定义关联表顺序。
2. 将外连接转化为内连接。
3. 使用等价变化规则。
4. 优化COUNT()、MIN()、MAX()
5. 预估并转化为常数表达式。
6. 覆盖索引扫描。
7. 子查询优化。
8. 提前终止查询。
9. 等值传播。
10. 列表IN()的比较。
### 6.4.4 查询执行引擎
### 6.4.5 返回结果给客户端
## 6.5 MySQL查询优化器的局限性
### 6.5.1 关联子查询
### 6.5.2 UNION的限制
### 6.5.3 索引合并优化
### 6.5.4 等值传递
### 6.5.5 并行执行
### 6.5.6 哈希关联
### 6.5.7 松散索引扫描
### 6.5.8 最大值和最小值优化
### 6.5.9 在同一个表上查询和更新
## 6.6 查询优化器的提示（hint）
## 6.7 优化特定类型的查询
### 6.7.1 优化COUNT()查询
